package us.dot.its.jpo.conflictmonitor.monitor.models.assessments;

import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map.Entry;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;

import us.dot.its.jpo.conflictmonitor.monitor.models.EventAssessment;
import us.dot.its.jpo.conflictmonitor.monitor.models.events.LaneDirectionOfTravelEvent;
import us.dot.its.jpo.conflictmonitor.monitor.utils.MathFunctions;
import us.dot.its.jpo.geojsonconverter.DateJsonMapper;

/**
 * Kafka Aggregator which takes multiple Lane Direction of Travel Events and combines them in the a Lane Direction of Travel Assessment
 */
@JsonIgnoreProperties(ignoreUnknown = true)
public class LaneDirectionOfTravelAggregator {

    /**
     * A list of Lane Direction of Travel Events to be used when generating a Lane Direction of Travel Assessment
     */
    private ArrayList<LaneDirectionOfTravelEvent> events = new ArrayList<>();

    /**
     * Autogenerated timestamp describing when this aggregation is created
     * @deprecated - This field is currently unused and should be removed pending review
     */
    private long aggregatorCreationTime;


    /**
     * Constructor function for Lane Direction of Travel Aggregator which sets the aggregationCreationTime to the current time in UTC milliseconds
     */
    public LaneDirectionOfTravelAggregator(){
        this.aggregatorCreationTime = ZonedDateTime.now().toInstant().toEpochMilli();
    }


    /**
     * The Add Function adds a new event to the list of events managed by this aggregator
     * @param event The LaneDirectionOfTravelEvent to add the list of events managed by this aggregator. 
     */
    @JsonIgnore
    public LaneDirectionOfTravelAggregator add(LaneDirectionOfTravelEvent event){
        events.add(event);
        
        return this;
    }

    /**
     * This function joins all of the events used by this aggregator into a LaneDirectionOfTravelAssessment.
     * @param tolerance The allowable heading tolerance in degrees of vehicles for this assessment
     * @param distanceTolerance The allowable distance tolerance in meters between the vehicle and the centerline
     * @param lookBackPeriodDays Specifies the number of days worth of data that should be included in the assessment. Events outside of this period are removed from the list and not included in the list. 
     * 
     */
    @JsonIgnore
    public LaneDirectionOfTravelAssessment getLaneDirectionOfTravelAssessment(double tolerance, double distanceTolerance, long lookBackPeriodDays){


        // Prune Events

        long lastEventTime = ZonedDateTime.now().toInstant().toEpochMilli();
        if(this.events.size() > 0){
            lastEventTime = this.events.get(this.events.size() -1).getTimestamp();
        }

        List<LaneDirectionOfTravelEvent> removeEvents = new ArrayList<>();
        for(LaneDirectionOfTravelEvent previousEvents: this.events){
            if(previousEvents.getTimestamp() + (lookBackPeriodDays *24* 3600*1000) <  lastEventTime){
                removeEvents.add(previousEvents);
            }else{
                break;
            }
        }
        events.removeAll(removeEvents);


        LaneDirectionOfTravelAssessment assessment = new LaneDirectionOfTravelAssessment();
        ArrayList<LaneDirectionOfTravelAssessmentGroup> assessmentGroups = new ArrayList<>();
        HashMap<Integer,HashMap<Integer,ArrayList<LaneDirectionOfTravelEvent>>> laneGroupLookup = new HashMap<>(); // laneId, Segment Index

        for(LaneDirectionOfTravelEvent event : this.events){
            assessment.setIntersectionID(event.getIntersectionID());
            assessment.setRoadRegulatorID(event.getRoadRegulatorID());
            
            HashMap<Integer, ArrayList<LaneDirectionOfTravelEvent>> laneLookup = laneGroupLookup.get(event.getLaneID());
            if(laneLookup == null){
                laneLookup = new HashMap<Integer, ArrayList<LaneDirectionOfTravelEvent>>();
                laneGroupLookup.put(event.getLaneID(), laneLookup);
            }
            
            

            ArrayList<LaneDirectionOfTravelEvent> groupSegment = laneLookup.get(event.getLaneSegmentNumber());

            if(groupSegment == null){
                groupSegment = new ArrayList<LaneDirectionOfTravelEvent>();
                laneLookup.put(event.getLaneSegmentNumber(), groupSegment);
            }

            groupSegment.add(event);
        }

        for(Entry<Integer, HashMap<Integer, ArrayList<LaneDirectionOfTravelEvent>>> entry: laneGroupLookup.entrySet()){
            for(Entry<Integer, ArrayList<LaneDirectionOfTravelEvent>> groups: entry.getValue().entrySet()){
                LaneDirectionOfTravelAssessmentGroup group = new LaneDirectionOfTravelAssessmentGroup();
                ArrayList<Double> headings = new ArrayList<>();
                ArrayList<Double> distances = new ArrayList<>();

                ArrayList<Double> inToleranceHeadings = new ArrayList<>();
                ArrayList<Double> inToleranceDistances = new ArrayList<>();

                group.setLaneID(entry.getKey());
                group.setSegmentID(groups.getKey());
                
                
                int inTolerance = 0;
                int outOfTolerance = 0;

                double expectedHeading = 0;
                for(LaneDirectionOfTravelEvent event: groups.getValue()){
                    expectedHeading = event.getExpectedHeading();
                    if(Math.abs(event.getMedianVehicleHeading() - expectedHeading) > tolerance){
                        outOfTolerance +=1;
                    }else{
                        inTolerance +=1;
                        inToleranceHeadings.add(event.getMedianVehicleHeading());
                        inToleranceDistances.add(event.getMedianDistanceFromCenterline());
                    }
                    headings.add(event.getMedianVehicleHeading());
                    distances.add(event.getMedianDistanceFromCenterline());
                }

                group.setInToleranceEvents(inTolerance);
                group.setOutOfToleranceEvents(outOfTolerance);
                group.setMedianInToleranceHeading(MathFunctions.getMedian(inToleranceHeadings));
                group.setMedianInToleranceCenterlineDistance(MathFunctions.getMedian(inToleranceDistances));
                group.setMedianCenterlineDistance(MathFunctions.getMedian(distances));
                group.setMedianHeading(MathFunctions.getMedian(headings));
                group.setTolerance(tolerance);
                group.setExpectedHeading(expectedHeading);
                group.setDistanceFromCenterlineTolerance(distanceTolerance);
                assessmentGroups.add(group);
            }
        }
        
        assessment.setLaneDirectionOfTravelAssessmentGroup(assessmentGroups);

        return assessment;
    }

    public ArrayList<LaneDirectionOfTravelEvent> getEvents() {
        return events;
    }

    public void setEvents(ArrayList<LaneDirectionOfTravelEvent> events) {
        this.events = events;
    }

    /**
     * @deprecated
     */
    public long getAggregatorCreationTime() {
        return aggregatorCreationTime;
    }

    /**
     * @deprecated
     */
    public void setAggregatorCreationTime(long aggregatorCreationTime) {
        this.aggregatorCreationTime = aggregatorCreationTime;
    }

    /**
     * This function returns an EventAssessment including a new Assessment, and the most recent event used to generate that Assessment.
     * @param tolerance The allowable heading tolerance in degrees of vehicles for this assessment
     * @param distanceTolerance The allowable distance tolerance in meters between the vehicle and the centerline
     * @param lookBackPeriodDays Specifies the number of days worth of data that should be included in the assessment. Events outside of this period are removed from the list and not included in the list. 
     * @return EventAssessment
     */
    @JsonIgnore
    public EventAssessment getEventAssessmentPair(double tolerance, double distanceTolerance, long lookBackPeriodDays){
        EventAssessment eventAssessment =  new EventAssessment();
        eventAssessment.setAssessment(getLaneDirectionOfTravelAssessment(tolerance, distanceTolerance, lookBackPeriodDays));
        if(this.events.size() >0){
            eventAssessment.setEvent(this.events.get(this.events.size()-1));
        }
        return eventAssessment;
    }
    

    @Override
    public String toString() {
        ObjectMapper mapper = DateJsonMapper.getInstance();
        String testReturn = "";
        try {
            testReturn = (mapper.writeValueAsString(this));
        } catch (JsonProcessingException e) {
            System.out.println(e);
        }
        return testReturn;
    }
    
}

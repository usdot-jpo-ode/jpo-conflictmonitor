package us.dot.its.jpo.conflictmonitor.monitor.models.assessments;

import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;

import us.dot.its.jpo.conflictmonitor.monitor.models.EventAssessment;
import us.dot.its.jpo.conflictmonitor.monitor.models.events.ConnectionOfTravelEvent;
import us.dot.its.jpo.geojsonconverter.DateJsonMapper;


/**
 * Kafka Aggregator which takes multiple Connection of Travel Events and combines them in the a Connection of Travel Assessment
 */
@JsonIgnoreProperties(ignoreUnknown = true)
public class ConnectionOfTravelAggregator {

    /**
     * A list of ConnectionOfTravelEvents to be used when generating a Connection of Travel Assessment
     */
    private ArrayList<ConnectionOfTravelEvent> events = new ArrayList<>();

    /**
     * Autogenerated timestamp describing when this aggregation is created
     * @deprecated - This field is currently unused and should be removed pending review
     */
    private long aggregatorCreationTime;

    
    /**
     * Constructor function for Connection of Travel Aggregator which sets the aggregationCreationTime to the current time in UTC milliseconds
     */
    public ConnectionOfTravelAggregator(){
        this.aggregatorCreationTime = ZonedDateTime.now().toInstant().toEpochMilli();
    }

    
    /**
     * The Add Function adds a new event to the list of events managed by this aggregator
     * @return ConnectionOfTravelAggregator - The same instance of a ConnectionOfTravelAssessmentAggregator that this function was called on. 
     */
    @JsonIgnore
    public ConnectionOfTravelAggregator add(ConnectionOfTravelEvent event){
        events.add(event);
        return this;
    }

     /**
     * This function joins all of the events used by this aggregator into a ConnectionOfTravelEventAssessment.
     * @param lookBackPeriodDays Specifies the number of days worth of data that should be included in the assessment. Events outside of this period are removed from the list and not included in the list.
     * @return ConnectionOfTravelAssessment - A ConnectionOfTravelAssessmentObject built from the events present in this aggregator
     */
    @JsonIgnore
    public ConnectionOfTravelAssessment getConnectionOfTravelAssessment(long lookBackPeriodDays){

        // Prune Events
        List<ConnectionOfTravelEvent> removeEvents = new ArrayList<>();

        long lastEventTime = ZonedDateTime.now().toInstant().toEpochMilli();
        if(this.events.size() > 0){
            lastEventTime = this.events.get(this.events.size() -1).getTimestamp();
        }
        
        for(ConnectionOfTravelEvent previousEvents: this.events){
            if(previousEvents.getTimestamp() + (lookBackPeriodDays *24* 3600*1000) < lastEventTime){
                removeEvents.add(previousEvents);
            }else{
                break;
            }
        }
        events.removeAll(removeEvents);


        ConnectionOfTravelAssessment assessment = new ConnectionOfTravelAssessment();
        ArrayList<ConnectionOfTravelAssessmentGroup> assessmentGroups = new ArrayList<>();
        HashMap<String,ConnectionOfTravelAssessmentGroup> connectionGroupLookup = new HashMap<>(); // laneId, Segment Index
        int intersectionID = -1;
        int roadRegulatorID = -1;
        for(ConnectionOfTravelEvent event : this.events){
            String eventKey = getEventKey(event);
            intersectionID = event.getIntersectionID();
            roadRegulatorID = event.getRoadRegulatorID();
            ConnectionOfTravelAssessmentGroup connectionGroup = connectionGroupLookup.get(eventKey);
            if(connectionGroup == null){
                connectionGroup = new ConnectionOfTravelAssessmentGroup();
                connectionGroup.setIngressLaneID(event.getIngressLaneID());
                connectionGroup.setEgressLaneID(event.getEgressLaneID());
                connectionGroup.setConnectionID(event.getConnectionID());
                assessmentGroups.add(connectionGroup);
                connectionGroupLookup.put(eventKey,connectionGroup);
            }
            connectionGroup.addConnectionOfTravelEvent(event);
        }
        
        assessment.setConnectionOfTravelAssessmentGroups(assessmentGroups);
        assessment.setIntersectionID(intersectionID);
        assessment.setRoadRegulatorID(roadRegulatorID);
        return assessment;
    }

    /**
     * Creates a new EventAssessment object with one assessment and the most recent event in this aggregator.
     * @param lookBackPeriodDays - The number of days in the past to generate the assessment for
     * @return EventAssessment 
     */
    @JsonIgnore
    public EventAssessment getEventAssessmentPair(long lookBackPeriodDays){
        EventAssessment eventAssessment =  new EventAssessment();
        eventAssessment.setAssessment(getConnectionOfTravelAssessment(lookBackPeriodDays));
        if(this.events.size() >0){
            eventAssessment.setEvent(this.events.get(this.events.size()-1));
        }
        return eventAssessment;
    }

    public String getEventKey(ConnectionOfTravelEvent event){
        return event.getIngressLaneID() + "-" + event.getEgressLaneID();
    }

    public ArrayList<ConnectionOfTravelEvent> getEvents() {
        return events;
    }

    public void setEvents(ArrayList<ConnectionOfTravelEvent> events) {
        this.events = events;
    }

    /**
     * @deprecated
     * @return long representing the utc millisecond timestamp of this event
     */
    public long getAggregatorCreationTime() {
        return aggregatorCreationTime;
    }

    /**
     * @param aggregatorCreationTime Long representing the time to at which this aggregator was generated.
     * @deprecated
     */
    public void setAggregatorCreationTime(long aggregatorCreationTime) {
        this.aggregatorCreationTime = aggregatorCreationTime;
    }

    /**
     * Converts this Object to a JSON string representation
     * @return String representing this object
     */
    @Override
    public String toString() {
        ObjectMapper mapper = DateJsonMapper.getInstance();
        String testReturn = "";
        try {
            testReturn = (mapper.writeValueAsString(this));
        } catch (JsonProcessingException e) {
            System.out.println(e);
        }
        return testReturn;
    }
    
}

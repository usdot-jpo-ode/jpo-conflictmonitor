package us.dot.its.jpo.conflictmonitor.monitor.models.assessments;

import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import lombok.Getter;
import lombok.Setter;
import us.dot.its.jpo.conflictmonitor.monitor.models.EventAssessment;
import us.dot.its.jpo.conflictmonitor.monitor.models.events.StopLineStopEvent;

/**
 * Kafka Aggregator which takes multiple StopLineStopEvent and combines them in the a StopLineStopAssessment
 */
@Getter
@Setter
@JsonIgnoreProperties(ignoreUnknown = true)
public class StopLineStopAggregator {
    
    /**
     * A list of StopLineStopEvent to be used when generating a StopLineStopAssessment
     */
    private ArrayList<StopLineStopEvent> events = new ArrayList<>();


    /**
     * Autogenerated timestamp describing when this aggregation is created
     * @deprecated - This field is currently unused and should be removed pending review
     */
    private long aggregatorCreationTime;

    
    /**
     * Constructor function for Connection of Travel Aggregator which sets the aggregationCreationTime to the current time in UTC milliseconds
     */
    public StopLineStopAggregator(){
        
        this.aggregatorCreationTime = ZonedDateTime.now().toInstant().toEpochMilli();
    }

    /**
     * The Add Function adds a new event to the list of events managed by this aggregator
     * @return StopLineStopAggregator - The same instance of a StopLineStopAggregator that this function was called on. 
     */
    @JsonIgnore
    public StopLineStopAggregator add(StopLineStopEvent event){
        
        // Skip stop line stop events where no connection was made.
        if(event.getSignalGroup() == -1){
            return this;
        }
        events.add(event);
        return this;
    }


    /**
     * This function joins all of the events used by this aggregator into a StopLineStopAssessment.
     * @param lookBackPeriodDays Specifies the number of days worth of data that should be included in the assessment. Events outside of this period are removed from the list and not included in the list.
     * @return StopLineStopAssessment - A StopLineStopAssessment built from the events present in this aggregator
     */
    @JsonIgnore
    public StopLineStopAssessment getStopLineStopAssessment(long lookBackPeriodDays){

        long lastEventTime = ZonedDateTime.now().toInstant().toEpochMilli();
        if(this.events.size() > 0){
            lastEventTime = this.events.get(this.events.size() -1).getFinalTimestamp();
        }

        List<StopLineStopEvent> removeEvents = new ArrayList<>();
        for(StopLineStopEvent previousEvents: this.events){
            if(previousEvents.getFinalTimestamp() + (lookBackPeriodDays *24* 3600*1000) <  lastEventTime){
                removeEvents.add(previousEvents);
            }else{
                break;
            }
        }
        events.removeAll(removeEvents);

        StopLineStopAssessment assessment = new StopLineStopAssessment();
        ArrayList<StopLineStopAssessmentGroup> assessmentGroups = new ArrayList<>();
        HashMap<Integer,StopLineStopAssessmentGroup> signalGroupLookup = new HashMap<>(); // laneId, Segment Index

        int intersectionID = -1;
        int roadRegulatorID = -1;

        for(StopLineStopEvent event : this.events){
            intersectionID = event.getIntersectionID();
            roadRegulatorID = event.getRoadRegulatorID();
            StopLineStopAssessmentGroup signalGroup = signalGroupLookup.get(event.getSignalGroup());
            if(signalGroup == null){
                signalGroup = new StopLineStopAssessmentGroup();
                signalGroup.setSignalGroup(event.getSignalGroup());
                assessmentGroups.add(signalGroup);
                signalGroupLookup.put(event.getSignalGroup(),signalGroup);
            }
            signalGroup.addStopLineStopEvent(event);
            
        }
        
        assessment.setIntersectionID(intersectionID);
        assessment.setRoadRegulatorID(roadRegulatorID);
        assessment.setStopLineStopAssessmentGroup(assessmentGroups);
        assessment.setTimestamp(ZonedDateTime.now().toInstant().toEpochMilli());

        return assessment;
    }


    /**
     * Creates a new EventAssessment object with one assessment and the most recent event in this aggregator.
     * @param lookBackPeriodDays - The number of days in the past to generate the assessment for
     * @return EventAssessment 
     */
    @JsonIgnore
    public EventAssessment getEventAssessmentPair(long lookBackPeriodDays){
        EventAssessment eventAssessment = new EventAssessment();
        eventAssessment.setAssessment(getStopLineStopAssessment(lookBackPeriodDays));
        if(this.events.size() >0){
            eventAssessment.setEvent(this.events.get(this.events.size()-1));
        }
        return eventAssessment;
    }
}

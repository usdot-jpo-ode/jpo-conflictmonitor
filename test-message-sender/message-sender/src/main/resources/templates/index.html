<!DOCTYPE HTML>
<html xmlns:th="http://www.thymeleaf.org" lang="en">

<head>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/0.4.14/leaflet.draw.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css"
        integrity="sha256-kLaT2GOSpHechhsozzB+flnD+zUyjE2LlfWPgU04xyI=" crossorigin="" />
    <link th:href="@{/style.css}" rel="stylesheet" />
    <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"
        integrity="sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM=" crossorigin=""></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/0.4.14/leaflet.draw.js"></script>
    <script src='https://unpkg.com/@turf/turf@6/turf.min.js'></script>
    <script src=" https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js "></script>
    <script th:src="@{/script-utilities.js}"></script>
    <title>Test Message Sender</title>
</head>

<body>
    <div class="container">
        <div style="display:none">
            <h3 class="sideHeader">SPAT Template</h3>
            <div class="sideItem jsonDocument" id="spatTemplate" contenteditable="true" spellcheck="false">
                Spat document
            </div>
            <h3 class="sideHeader">BSM Template</h3>
            <div class="sideItem jsonDocument" id="bsmTemplate" contenteditable="true" spellcheck="false">
            </div>


        </div>
        <div class="side" style="width: 20%">
            
            <h3 class="sideHeader">SPAT Phases</h3>
            <div class="sideItem tableContainer" id="spatTableContainer" style="padding: 0" >
                <table id="spatTable" class="selectTable">
                </table>
            </div>
            <div class="sideItem"></div>
        </div>


        <div id="map">
        </div>
        <div class="side" style="width: 25%">
            <div class="sideItem">

                <div >
                    <a th:href="@{help}" target="_blank" style="font-size:1em; font-weight:bold">Help</a>
                </div>
                
                    
                <div id="uploads">
                    <hr />
                    <h3>Uploads</h3>
                    <label for="ulBsms">BSMs</label><input type="file" id="ulBsms" accept=".jsonl,.ndjson,.csv,.txt,.json" onchange="uploadBsms(this);" />
                    <br/>
                    <label for="ulSpats">SPATs</label><input type="file" id="ulSpats" accept=".jsonl,.ndjson,.csv,.json" onchange="uploadSpats(this);" />
                    <br/>
                    <label for="btnProcessedSpatUpload">ProcessedSpats</label><input type="file" id="btnProcessedSpatUpload" accept=".jsonl,.ndjson,.csv,.json"
                        onchange="uploadProcessedSpats(this);"/>
                    <br/>

                    <label for="btnOdeMapJsonUpload">MAP</label><input type="file" id="btnOdeMapJsonUpload" accept=".json,.csv"
                        onchange="uploadOdeMapJson(this);" />
                    <br/>
                    <label for="btnProcessedMapUpload">ProcessedMap</label><input type="file" id="btnProcessedMapUpload" accept=".json,.csv"
                           onchange="uploadMapGeojson(this);"/>

                </div>
                
                <hr />
                
                    

                    
                <div id="mapControls">
                    
                    <h3>Send MAP</h3>
                    <button type="button" onclick="startSendingMap();">Start</button>
                    <button type="button" onclick="stopSendingMap();">Stop</button>
                    <br />
                    <input type="range" min="500" max="1500" value="1000" step="50" name="mapInterval"
                        id="mapInterval" oninput="this.nextElementSibling.value = this.value" />
                    <output>1000</output>
                    <br />
                    <label for="mapInterval">MAP Interval (ms)</label>

                </div>
                <hr />

                <div id="rtSpatControls">

                    <h3>Send Selected SPAT Phases</h3>
                    <button type="button" onclick="sendSpatsRealTime();">Start</button>
                    <button type="button" onclick="stopSendingSpatsRealTime();">Stop</button>
                    <label for="spatLoop">Loop</label>
                    <input type="checkbox" id="spatLoop"/><br/>
                </div>
                <hr />
                <div id="bsmControls">
                    
                    <h3>Send BSMs</h3>
                    <button type="button" onclick="sendBsmsRealTime();">Start</button>
                    <button type="button" onclick="stopSendingBsms();">Stop</button>
                    <label for="bsmFixedInterval">Fixed Interval</label>
                    <input type="checkbox" id="bsmFixedInterval" checked /><br/>
                    <input type="range" min="10" max="1000" value="100" step="10" name="bsmInterval"
                        id="bsmInterval" oninput="this.nextElementSibling.value = this.value"/>
                    <output>100</output><br/>
                    <label for="bsmInterval">BSM Interval (ms)</label>
                </div>

                
                <hr />
                <div>
                    <h3>Download Created BSMs</h3>
                    <button type="button" onclick="downloadBsms();">Download BSMs</button>
                </div>
                <hr/>
                <div id="scriptControls">
                    <h3>Record Scripts</h3>
                    <button type="button" onclick="startRecording();">Start</button>
                    <button type="button" onclick="stopRecording();">Stop</button>
                    <button type="button" onclick="downloadScript();">Download</button>
                    <button type="button" onclick="clearScript();">Clear</button>
                </div>

                <hr />

            </div>

        </div>
    </div>
</body>
<script>

    const map = L.map('map').setView([39, -98], 5);

    /* Base Map */
    /* See https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#expression-inlining */
    const basemapUrl = '[(${basemapUrl})]';
    console.log('basemapUrl = ' + basemapUrl);
    const basemapAttrib = '[(${basemapAttribution})]';
    console.log('basemapAttribution = ' + basemapAttrib);

    const empty = L.tileLayer('', {maxZoom: 22});
    const basemap = L.tileLayer(basemapUrl, {maxZoom: 22, attribution: basemapAttrib});


    const drawnItems = new L.FeatureGroup();

    const bsmList = [];  /* Array of BSM locations */
    const spatList = [];

    let bsmTemplate = ""; /* BSM template string */

    // Flag indicates whether the SPAT and spatList contain raw or ProcessedSpats.
    let useProcessedSpats = false;
    let useProcessedMap = false;


    const diffSpatEvents = [];


    const script = [];

    const baseMaps = {
        basemapAttrib: basemap.addTo(map)
    };

    const overlayMaps = {
        'Draw BSM Layer': drawnItems
    };


    const layerControl = L.control.layers(baseMaps, overlayMaps, {
        positiion: 'topright',
        collapsed: true,
        hideSingleBase: true
    }).addTo(map);


    /* Shape draw controls */

    map.addLayer(drawnItems);


    const drawControl = new L.Control.Draw({
        position: 'topleft',
        draw: {
            polyline: false,
            polygon: false,
            rectangle: false,
            circle: false,
            marker: false,
            circlemarker: {
                color: '#f00',
                fillOpacity: 0.9,
                stroke: false,
                radius: 5
            }
        },
        edit: {
            featureGroup: drawnItems,
            remove: true,
            edit: false
        }
    });
    map.addControl(drawControl);


    map.on(L.Draw.Event.CREATED, function (e) {
        var type = e.layerType,
            layer = e.layer;
        if (type == 'circlemarker') {

            drawnItems.addLayer(layer);
            console.log('Placed point');
            console.log(layer);

            const lon = layer._latlng.lng;
            const lat = layer._latlng.lat;

            /* Save the coordinates with the current timestamp */
            const ts = Date.now();

            const prevBsm = bsmList.length > 0 ? bsmList[bsmList.length - 1] : null;
            const prevCoords = prevBsm?.coords;
            //var prevTimestamp = prevBsm?.timestamp;
            const prevMsgCnt = prevBsm != null ? prevBsm.msgCnt : 0;
            const msgCnt = (prevMsgCnt + 1) % 128;

            // Get Origin IP and temp ID from template
            const bsmTemplate = bsmTemplate;
            const originIp = bsmTemplate.metadata.originIp;
            const id = bsmTemplate.payload.data.coreData.id;

            let heading = bsmTemplate.payload.data.coreData.heading;
            let speed = bsmTemplate.payload.data.coreData.speed;
            const deltaTimestampMillis = 100;
            if (prevCoords != null) {
                [heading, speed] = getHeadingAndSpeed(prevCoords, [lon, lat], deltaTimestampMillis);
                speed = Math.round(speed * 100) / 100;             
                
                // Since calculated heading won't be accurate when vehicle is stopped,
                // use previous heading if speed is < 0.5 m/s
                if (speed < 0.5) { 
                    heading = prevBsm.heading;
                }
            }
            const bsm = { odeReceivedAt: ts, timestamp: ts, coords: [lon, lat], heading: heading, speed: speed, id: id, msgCnt: msgCnt, originIp: originIp };

            /* Tag the layer with the bsm timestamp so we can find it to update or delete */
            layer.bsmTimestamp = ts;

            bsmList.push(bsm);
            //console.log(bsmList);

            /* Keep circlemarker button in edit mode
               TODO Figure out some way to do this other than this hack */
            throw 'Throwing exception to keep the circlemarker in edit mode.  Not ideal but it works.'

        } else {
            console.log('layerType ' + type + ' not used');
        }
    });


    map.on('draw:edited', function (e) {
        /* TODO update bsmList */
        console.log(e);

    });

    map.on('draw:deleted', function (e) {
        console.log(e);
        /* Remove all items */
        bsmList.length = 0;
        /* TODO: Don't assume all items were deleted */
    });



    async function getBsmTemplate() {
        const response = await fetch('BSMTemplate.json');
        const text = await response.text();
        bsmTemplate = JSON.parse(text);
    }



    let geojsonLayer = undefined;
    let connectingLayer = undefined;

    function setMapGeojson(mapGeojson) {
        console.log("MAP Geojson:");
        console.log(mapGeojson);
        if (geojsonLayer) {
            map.removeLayer(geojsonLayer);
            layerControl.removeLayer(geojsonLayer);
        }
        geojsonLayer = L.geoJSON(mapGeojson, {
            style: {
                color: '#f0f',
                width: '1px',
                opacity: 1
            },
            onEachFeature: addPropertiesTooltip
        }).addTo(map);
        layerControl.addOverlay(geojsonLayer, 'MAP Geojson');
        map.fitBounds(geojsonLayer.getBounds());
    }

    function setConnectingLanesGeojson(connectingGeojson) {
        console.log("MAP Connections:");
        console.log(connectingGeojson);
        if (connectingLayer) {
            map.removeLayer(connectingLayer);
            layerControl.removeLayer(connectingLayer);
        }
        connectingLayer = L.geoJSON(connectingGeojson, {
            style: {
                color: '#0f0',
                width: '1px',
                opacity: 1
            },
            onEachFeature: addPropertiesTooltip
        }).addTo(map);
        layerControl.addOverlay(connectingLayer, "Connections");
    }

    function addPropertiesTooltip(feature, layer) {
        let popupContent = '';
        for (const key in feature.properties) {
            const val = feature.properties[key];
            // Include numbers only
            if (_.isNumber(val)) {
                popupContent += key + ' = ' + val + '<br/>';
            }
        }
        layer.bindPopup(popupContent, { autoClose: false, closeOnClick: false });
    }



    getBsmTemplate();



    function sendBsmsRealTime() {
        if (bsmList.length < 1) return;
        console.log("sendBsmsRealTime");
        sendBsmListRealTime(bsmList, false);  // Calculate delay
    }

    const MAX_DELAY = 5000;

    function sendBsmListRealTime(theBsmList, noDelay) {
        BSM_SEND = true;
        document.getElementById('bsmControls').style = 'background-color:lightgreen';


        const startIn = 0;
        const now = Date.now();
        const firstTimestamp = theBsmList[0].odeReceivedAt;
        let offset = now - firstTimestamp + startIn;
        for (const bsm of theBsmList) {
            bsm.timestamp += offset;
            bsm.odeReceivedAt += offset;
        }



        let idx = 0;

        // Use random BSM ID
        const bsmId = getRandomBsmID();

        // Use originIp from MAP, if available
        const originIp = getOriginIpForBsm();

        // Send each with timer
        let nextTime = startIn;
        console.log("Sending BSM in " + nextTime + " ms");
        let correctionOffset = 0;
        const bsmFixedInterval = document.getElementById('bsmFixedInterval');
        const bsmInterval = document.getElementById('bsmInterval');
        setTimeout(function sendBsmTimed() {
            if (!BSM_SEND) return;
            const bsm = theBsmList[idx];
            const id = bsm.id;
            const postDataItem = buildBsmFromTemplate(bsm, bsmTemplate, bsmId, originIp);
            sendBsmAsync(postDataItem).then(successCallback, failureCallback);
            if (idx < theBsmList.length - 1) {
                ++idx;
                if (bsmFixedInterval.checked) {
                    noDelay = false;
                    nextTime = bsmInterval.value;
                } else {
                    const nextBsm = theBsmList[idx];
                    nextTime = nextBsm.odeReceivedAt - Date.now() - correctionOffset;

                    if (nextTime < 0) {
                        nextTime = 0;
                        if (nextTime < -MAX_DELAY) {
                            correctionOffset = 0;
                        }
                    }

                    if (nextTime > MAX_DELAY) {
                        correctionOffset = nextTime - MAX_DELAY;
                        nextTime = MAX_DELAY;
                        //offset = Date.now() - nextBsm.odeReceivedAt;
                    }
                    nextTime = noDelay ? 0 : nextTime;
                }
                console.log("Sending BSM id = " + id + " in " + nextTime + " ms");
                setTimeout(sendBsmTimed, noDelay ? 0 : nextTime);
            } else {
                console.log("Completed Sending BSMs with id = " + id);
                stopSendingBsms();
            }
        }, nextTime);
    }

    var BSM_SEND = true;

    function stopSendingBsms() {
        BSM_SEND = false;
        document.getElementById('bsmControls').style = '';
    }

    function buildBsmFromTemplate(bsm, bsmTemplate, bsmId, originIp) {
        // Copy via serialization
        const bsmJson = JSON.stringify(bsmTemplate);
        const bsmObj = JSON.parse(bsmJson);
        bsmObj.payload.data.coreData.id = bsmId;
        bsmObj.payload.data.coreData.msgCnt = bsm.msgCnt;
        bsmObj.payload.data.coreData.speed = bsm.speed;
        bsmObj.payload.data.coreData.heading = bsm.heading;
        bsmObj.payload.data.coreData.position.longitude = bsm.coords[0];
        bsmObj.payload.data.coreData.position.latitude = bsm.coords[1];
        const dt = new Date(bsm.timestamp);
        const dtMillis = dt.getTime();
        const dtMinute = new Date(dt.getFullYear(), dt.getMonth(), dt.getDate(), dt.getHours(), dt.getMinutes(), 0, 0);
        const minuteMillis = dtMinute.getTime();
        const millis = dtMillis - minuteMillis;
        bsmObj.payload.data.coreData.secMark = millis;
        bsmObj.metadata.originIp = originIp;


        bsmObj.metadata.odeReceivedAt = new Date(bsm.odeReceivedAt).toISOString();
        return bsmObj;
    }

    function getRandomBsmID() {
        return genRanHex(8);
    }

    // Source: https://stackoverflow.com/questions/58325771/how-to-generate-random-hex-string-in-javascript
    function genRanHex(size) {
        let output = '';
        for (let i = 0; i < size; ++i) {
            output += (Math.floor(Math.random() * 16)).toString(16);
        }
        return output;
    }

    function getOriginIpForBsm() {
        const defaultIp = "127.0.0.1";
        if (useProcessedMap) {
            if (odeMapTemplate?.properties?.originIp)
                return odeMapTemplate.properties.originIp;
            else
                return defaultIp;
        } else {
            if (odeMapTemplate?.metadata?.originIp)
                return odeMapTemplate.metadata.originIp;
            else
                return defaultIp;
        }
    }

    async function sendBsmAsync(postDataItem) {
        if (RECORD_SCRIPT) {
            script.push(scriptUtil.buildScriptFromBsm(postDataItem));
        }
        const response = await fetch('/kafka/topic.OdeBsmJson', {
            method: 'POST',
            cache: 'no-cache',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(postDataItem)
        });
        return response;
    }









    function successCallback(e) {
        //console.log("success");
        //console.log(e);
    }

    function failureCallback(e) {
        console.log("failure");
        console.log(e);
    }

    function uploadBsms(e) {
        console.log("uploadBsms");


        if (e?.files.length > 0) {
            let file = e.files[0];

            file.text().then(text => {
                // Clear exising bsms
                bsmList.length = 0;
                const lines = text.split(/\r?\n/);



                for (const line of lines) {
                    if (line) {
                        try {
                            const json = JSON.parse(line);
                            var bsm = extractBsmData(json);
                            bsmList.push(bsm);
                            addCircleMarker(bsm);
                        } catch (ex) {
                            console.error(ex);
                        }
                    }
                }

                console.log("Uploaded " + bsmList.length + " BSMs");

                // Find distinct BSM IDs
                const idList = bsmList.map((value, idx, arr) => value.id + '');
                const idSet = new Set();
                for (const id of idList) {
                    idSet.add(id);
                }
                console.log("idSet");
                console.log(idSet);

                // Sort by ode ingest time
                bsmList.sort((a, b) => a.odeReceivedAt - b.odeReceivedAt);
            });
        }
    }

    //
    // Function: extractBsmData
    //
    // Extracts key data from a BSM
    //
    // Input: An ODE JSON BSM object
    //
    // Output: A flat JSON object containing the key useful data from the BSM
    // including timestamps, coordinates, speed, heading, etc.
    //
    function extractBsmData(json) {
        const dtReceivedAtMillis = Date.parse(json.metadata.odeReceivedAt);
        const dt = new Date(dtReceivedAtMillis);
        //console.log(dt);
        const minuteMillis = Date.UTC(dt.getUTCFullYear(), dt.getUTCMonth(), dt.getUTCDate(), dt.getUTCHours(), dt.getUTCMinutes(), 0, 0);
        const coreData = json.payload.data.coreData;
        const secMark = coreData.secMark;
        const millis = minuteMillis + secMark;

        const position = coreData.position;
        const lon = position.longitude;
        const lat = position.latitude;

        const heading = coreData.heading;
        const speed = coreData.speed;
        const id = coreData.id + ''; // Cast to string
        const msgCnt = coreData.msgCnt;

        const originIp = json.metadata.originIp;


        const bsm = { odeReceivedAt: dtReceivedAtMillis, timestamp: millis, coords: [lon, lat], heading: heading, speed: speed, id: id, msgCnt: msgCnt, originIp: originIp };
        //console.log(bsm);
        return bsm;
    }

    

    function addCircleMarker(bsm) {
        const latlng = L.latLng(bsm.coords[1], bsm.coords[0]);
        const options = {
            color: '#f00',
            fillOpacity: 0.9,
            stroke: false,
            radius: 5
        };
        const circlemarker = L.circleMarker(latlng, options);
        drawnItems.addLayer(circlemarker);
    }




    function uploadMapGeojson(e) {
        console.log("uploadMapGeojson (ProcessedMap)");
        if (e?.files.length > 0) {
            let file = e.files[0];
            file.text().then(text => {
                const json = JSON.parse(text);
                console.log(json);
                setMapGeojson(json.mapFeatureCollection);
                setConnectingLanesGeojson(json.connectingLanesFeatureCollection);
                odeMapTemplate = json;
                useProcessedMap = true;
            });
        }
    }

    function uploadOdeMapJson(e) {
        console.log("uploadOdeMapJson");
        if (e?.files.length > 0) {
            let file = e.files[0];
            console.log("MAP JSON File:");
            console.log(file);
            file.text().then(text => {
                odeMapJsonToGeojson(text);
                useProcessedMap = false;
            });
        }
    }



    var odeMapTemplate;


    function odeMapJsonToGeojson(text) {
        odeMapTemplate = JSON.parse(text);
        odeMapJsonToGeojsonAsync(text).then(
            response => response.json(),
            failureCallback
        ).then(
            // Success callback
            json => {
                console.log(json);
                setMapGeojson(json.mapFeatureCollection);
                setConnectingLanesGeojson(json.connectingLanesFeatureCollection);
            },
            failureCallback
        );
    }

    async function odeMapJsonToGeojsonAsync(json) {
        return await fetch('/odeMapJsonToGeojson', {
            method: 'POST',
            cache: 'no-cache',
            headers: {
                'Content-Type': 'application/json'
            },
            body: json
        });
    }

    var MAP_SEND = true;

    function startSendingMap() {
        MAP_SEND = true;
        document.getElementById('mapControls').style = 'background-color:lightgreen';
        let intervalMs = document.getElementById('mapInterval').value;
        setTimeout(function sendMapTimed() {
            if (!MAP_SEND) return;
            intervalMs = document.getElementById('mapInterval').value;

            if (useProcessedMap) {
                const processedMap = buildProcessedMapFromTemplate(odeMapTemplate);
                console.log("Sending ProcessedMap, next " + intervalMs);
                sendProcessedMapAsync(processedMap).then(successCallback, failureCallback);
            } else {
                const odeMap = buildMapFromTemplate(odeMapTemplate);
                console.log("Sending MAP, next " + intervalMs);
                sendMapAsync(odeMap).then(successCallback, failureCallback);
            }

            setTimeout(sendMapTimed, intervalMs);
        }, intervalMs);
    }

    function stopSendingMap() {
        MAP_SEND = false;
        document.getElementById('mapControls').style = '';
    }

    async function sendMapAsync(odeMap) {
        if (RECORD_SCRIPT) {
            script.push(scriptUtil.buildScriptFromMap(odeMap));
        }
        await fetch('/kafka/topic.OdeMapJson', {
            method: 'POST',
            cache: 'no-cache',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(odeMap)
        });
    }

    async function sendProcessedMapAsync(processedMap) {
        const key = {
            rsuId: processedMap.properties.originIp,
            intersectionId: processedMap.properties.intersectionId
        };
        if (RECORD_SCRIPT) {
            script.push(scriptUtil.buildScriptFromProcessedMap(processedMap, key));
        }
        await fetch ('/kafka/topic.ProcessedMap', {
            method: 'POST',
            cache: 'no-cache',
            headers: {
                'Content-Type': 'application/json',
                'x-kafka-key': JSON.stringify(key)
            },
            body: JSON.stringify(processedMap)
        });
    }

    function buildMapFromTemplate() {
        let mapCopy = JSON.parse(JSON.stringify(odeMapTemplate));
        const nowMillis = Date.now();
        mapCopy.metadata.odeReceivedAt = new Date(nowMillis).toISOString();
        return mapCopy;
    }

    function buildProcessedMapFromTemplate() {
        let processedMap = JSON.parse(JSON.stringify(odeMapTemplate));
        const nowMillis = Date.now();
        const strTimestamp = new Date(nowMillis).toISOString();
        processedMap.properties.odeReceivedAt = strTimestamp;
        processedMap.properties.timeStamp = strTimestamp;
        return processedMap;
    }

    

    function getHeadingAndSpeed(coords1, coords2, deltaTimestampMillis) {
        const point1 = turf.point(coords1);
        const point2 = turf.point(coords2);
        const heading = Math.round(turf.bearingToAzimuth(turf.bearing(point1, point2)) * 10) / 10;
        const distanceMeters = turf.distance(point1, point2, {units: 'kilometers'}) * 1000;
        const tSeconds = deltaTimestampMillis / 1000;
        const speed = distanceMeters / tSeconds;
        return [heading, speed];
    }

    function downloadText(filename, text) {
        var e = document.createElement('a');
        e.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
        e.setAttribute('download', filename);
        e.style.display = 'none';
        document.body.appendChild(e);
        e.click();
        document.body.removeChild(e);
    }

    function downloadBsms() {
        let ldjson = '';


        // Use random BSM ID
        const bsmId = getRandomBsmID();

        // Use originIp from MAP, if available
        const originIp = getOriginIpForBsm();

        for (const bsm of bsmList) {
            const postDataItem = buildBsmFromTemplate(bsm, bsmTemplate, bsmId, originIp);
            ldjson += JSON.stringify(postDataItem) + '\n';
        }
        downloadText('BSMData.jsonl', ldjson);
    }






    // ------------------------- SPAT Upload --------------------------------

    function uploadSpats(e) {
        console.log("uploadSpats");
        if (e?.files.length > 0) {
            let file = e.files[0];
            file.text().then(text => {
                // Clear existing spats
                spatList.length = 0;
                //processedSpatList.length = 0;
                diffSpatEvents.length = 0;
                const lines = text.split(/\r?\n/);
                console.log("Read " + lines.length + " spats from file");

                // Set the first SPAT as the template
                setSpatTemplate(lines[0], false)
                for (const line of lines) {
                    if (line) {
                        const json = JSON.parse(line);
                        const spat = extractSpatData(json);
                        spatList.push(spat);
                    }
                }

                // Sort by ingest time
                spatList.sort((a, b) => a.odeReceivedAt - b.odeReceivedAt);

                // Split the spats into an array of streams with the same phase
                 
                // Get the first phase and start the stream of spats
                const firstSpat = _.head(spatList);
                const firstEvent = firstSpat.events;
                let previousEvent = uniqueSpatId(firstEvent);
                previousEvent.spats = [];
                previousEvent.spats.push(firstSpat);
                diffSpatEvents.push(previousEvent);

                for (const spat of spatList) {
                    const event = spat.events;
                    // Remove timing
                    const strippedEvent = uniqueSpatId(event);
                    if (!_.isEqual(strippedEvent, previousEvent)) {
                        // The phase is different, create a new stream
                        previousEvent = strippedEvent;
                        previousEvent.spats = [];
                        previousEvent.spats.push(spat);
                        diffSpatEvents.push(previousEvent);
                    } else {
                        // The phase is the same, add to the latest stream
                        previousEvent.spats.push(spat);
                    }
                }
                console.log("Found " + diffSpatEvents.length + " diff spat events");
                

                // Group the first stream of each unique spat id with the event
                for (const event of diffSpatEvents) {                   
                    const firstItem = _.head(event.spats);
                    const lastItem = _.last(event.spats);
                    event.firstOdeTime = firstItem.odeReceivedAt;
                    event.lastOdeTime = lastItem.odeReceivedAt;
                    event.firstTimestamp = firstItem.timestamp;
                    event.lastTimestamp = lastItem.timestamp;
                    event.odeDurationMs = event.lastOdeTime - event.firstOdeTime;
                    event.durationMs = event.lastTimestamp - event.firstTimestamp;
                }
                

                const earliestOdeTime = _.head(diffSpatEvents).firstOdeTime;
                for (const event of diffSpatEvents) {
                    event.firstOdeTimeOffset = event.firstOdeTime - earliestOdeTime;
                }

                //console.log(uniqueSpatEvents);
                showSpatTable(diffSpatEvents);
            })
        }
    }

    function uploadProcessedSpats(e) {
        console.log("uploadProcessedSpats");
        if (e?.files.length > 0) {
            let file = e.files[0];
            file.text().then(text => {
                // Clear existing spats
                spatList.length = 0;
                //processedSpatList.length = 0;
                diffSpatEvents.length = 0;
                const lines = text.split(/\r?\n/);
                console.log("Read " + lines.length + " ProcessedSpats from file");

                // Set the first ProcessedSpat as the template
                setSpatTemplate(lines[0], true);


                for (const line of lines) {
                    if (line) {
                        const json = JSON.parse(line);
                        const spat = extractProcessedSpatData(json);
                        spatList.push(spat);
                    }
                }

                // Sort by ingest time
                spatList.sort((a, b) => a.odeReceivedAt - b.odeReceivedAt);

                // Split the spats into an array of streams with the same phase

                // Get the first phase and start the stream of spats
                const firstSpat = _.head(spatList);
                const firstEvent = firstSpat.events;
                let previousEvent = uniqueSpatId(firstEvent);
                previousEvent.spats = [];
                previousEvent.spats.push(firstSpat);
                diffSpatEvents.push(previousEvent);

                for (const spat of spatList) {
                    const event = spat.events;
                    // Remove timing
                    const strippedEvent = uniqueSpatId(event);
                    if (!_.isEqual(strippedEvent, previousEvent)) {
                        // The phase is different, create a new stream
                        previousEvent = strippedEvent;
                        previousEvent.spats = [];
                        previousEvent.spats.push(spat);
                        diffSpatEvents.push(previousEvent);
                    } else {
                        // The phase is the same, add to the latest stream
                        previousEvent.spats.push(spat);
                    }
                }
                console.log("Found " + diffSpatEvents.length + " diff spat events");


                // Group the first stream of each unique spat id with the event
                for (const event of diffSpatEvents) {
                    const firstItem = _.head(event.spats);
                    const lastItem = _.last(event.spats);
                    event.firstOdeTime = firstItem.odeReceivedAt;
                    event.lastOdeTime = lastItem.odeReceivedAt;
                    event.firstTimestamp = firstItem.timestamp;
                    event.lastTimestamp = lastItem.timestamp;
                    event.odeDurationMs = event.lastOdeTime - event.firstOdeTime;
                    event.durationMs = event.lastTimestamp - event.firstTimestamp;
                }


                const earliestOdeTime = _.head(diffSpatEvents).firstOdeTime;
                for (const event of diffSpatEvents) {
                    event.firstOdeTimeOffset = event.firstOdeTime - earliestOdeTime;
                }

                //console.log(uniqueSpatEvents);
                showSpatTable(diffSpatEvents);
            })
        }
    }



    function setSpatTemplate(text, isProcessedSpat) {
        useProcessedSpats = isProcessedSpat;
        const json = JSON.parse(text);
        document.getElementById("spatTemplate").innerText = JSON.stringify(json, null, 1);
    }


    //
    // Function: extractSpatData
    //
    // Extracts key data from a SPAT message
    //
    // Input: An ODE JSON SPAT object
    //
    // Out
    function extractSpatData(json) {
        const metadata = json?.metadata;
        const dtReceivedAtMillis = Date.parse(metadata.odeReceivedAt);
        const dt = new Date(dtReceivedAtMillis);
        const minuteMillis = Date.UTC(dt.getUTCFullYear(), dt.getUTCMonth(), dt.getUTCDate(), dt.getUTCHours(), dt.getUTCMinutes(), 0, 0);
       
        const payload = json.payload;
        const data = payload.data;
        const isl = data.intersectionStateList;
        const isl2 = isl.intersectionStatelist;
        const intersection = isl2[0];
        const secMark = intersection.timeStamp;
        const millis = minuteMillis + secMark;
        const movementList = intersection.states?.movementList;
        const msgCnt = intersection.revision;
        
        const events = [];

        
        for (const movement of movementList) {
            const signalGroup = movement.signalGroup;
            const eventList = movement.state_time_speed?.movementEventList;
            // Assume 1 event
            let eventState;
            let minEndTime;
            let maxEndTime;
            for (const event of eventList) {
                eventState = event.eventState;
                minEndTime = event?.timing?.minEndTime;
                maxEndTime = event?.timing?.maxEndTime;
            }
            events.push({
                signalGroup: signalGroup,
                eventState: eventState,
                minEndTime: minEndTime,
                maxEndTime: maxEndTime
            });
            
        }

        const spat = { 
            odeReceivedAt: dtReceivedAtMillis, 
            timestamp: millis,
            msgCnt: msgCnt,
            events: events,
            spatId: serializeSpatId(uniqueSpatId(events)),
            json: json
        };

        //console.log(spat);
        return spat;
    }

    function extractProcessedSpatData(json) {
        const dtReceivedAtMillis = Date.parse(json.odeReceivedAt);
        let utcTimestampMillis = null;
        if (json.utcTimestamp != null) {
            const utcTimestamp = json.utcTimestamp;
            utcTimestampMillis = Date.parse(utcTimestamp);
        } else {
            utcTimestampMillis = dtReceivedAtMillis;
        }

        const msgCnt = json.revision;
        const states = json.states;
        const events = [];
        for (const state of states) {
            const signalGroup = state.signalGroup;
            const eventList = state.stateTimeSpeed;
            // Assume only 1 event
            let eventState;
            let minEndTime;
            let maxEndTime;
            for (const event of eventList) {
                eventState = event.eventState;
                const timing = event["timing"];
                if (timing != null) {
                    if (timing.minEndTime != null) {
                        minEndTime = Date.parse(timing.minEndTime);
                    }
                    maxEndTime = Date.parse(timing.maxEndTime);
                }
            }
            events.push({
                signalGroup: signalGroup,
                eventState: eventState,
                minEndTime: minEndTime,
                maxEndTime: maxEndTime
            });
        }
        const spat = {
            odeReceivedAt: dtReceivedAtMillis,
            timestamp: utcTimestampMillis,
            msgCnt: msgCnt,
            events: events,
            spatId: serializeSpatId(uniqueSpatId(events)),
            json: json
        }
        //console.log(spat);
        return spat;
    }



    function uniqueSpatId(event) {
        const spatId = new Map();
        for (const item of event) {
            spatId.set(item.signalGroup, item.eventState);
        }
        //console.log(spatId);
        return spatId;
    }

    function serializeSpatId(id) {
        return JSON.stringify(Array.from(id.entries()));
    }



    
    
    function showSpatTable(spatIds) {
        const tbl = document.getElementById("spatTable");
        // Clear the old table
        tbl.innerHTML = '';
        const tBody = document.createElement("tbody");
        const hr = document.createElement("tr");
        const hd1 = document.createElement("th");
        const hd2 = document.createElement("th");
        const hd3 = document.createElement("th");
        const hd4 = document.createElement("th");

        const hText1 = document.createTextNode("x");
        const hText2 = document.createTextNode("Start (s)");
        const hText3 = document.createTextNode("Î” (s)");
        const hText4 = document.createTextNode("State / Signal Groups");

        hd1.appendChild(hText1);
        hd2.appendChild(hText2);
        hd3.appendChild(hText3);
        hd4.appendChild(hText4);

        hr.appendChild(hd1);
        hr.appendChild(hd2);
        hr.appendChild(hd3);
        hr.appendChild(hd4);

        tBody.appendChild(hr);

        for (let idx = 0; idx < spatIds.length; ++idx) {
            const spatId = spatIds[idx];
            const groupedStates = groupByEventState(spatId);
            const rowGroup = document.createElement("tr");

            const selectCell = document.createElement("td");
            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.id = 'spatState' + idx;
            checkbox.checked = false;
            selectCell.appendChild(checkbox);
            rowGroup.appendChild(selectCell);

            const tsCell = document.createElement("td");
            const tsText = document.createTextNode((spatId.firstOdeTimeOffset/1000).toString());
            tsCell.appendChild(tsText);
            rowGroup.appendChild(tsCell);

            const dCell = document.createElement("td");
            const dText = document.createTextNode((Math.round(spatId.odeDurationMs/1000)).toString());
            dCell.appendChild(dText);
            rowGroup.appendChild(dCell);

            const groupCell = document.createElement("td");
            
            for (const [eventState, signalGroups] of Object.entries(groupedStates)) {
                const cellText1 = document.createTextNode(_.upperFirst(_.camelCase(eventState)) + ' ');
                groupCell.appendChild(cellText1);
                const cellText2 = document.createTextNode(JSON.stringify(signalGroups));
                groupCell.appendChild(cellText2);
                groupCell.appendChild(document.createElement("br"));
            }
            rowGroup.appendChild(groupCell);
            tBody.appendChild(rowGroup);
        }

        tbl.appendChild(tBody);
    }

    function groupByEventState(spatId) {
        const eventStateMap = {};
        for (const [signalGroup, eventState] of spatId) {
            let signalGroups;
            if (!eventStateMap.hasOwnProperty(eventState)) {
                signalGroups = [];
                eventStateMap[eventState] = signalGroups;
            } else {
                signalGroups = eventStateMap[eventState];
            }
            signalGroups.push(signalGroup);
        }
        return eventStateMap;
    }



    async function sendSpatAsync(odeSpat) {
        if (RECORD_SCRIPT) {
            script.push(scriptUtil.buildScriptFromSpat(odeSpat));
        }
        await fetch('/kafka/topic.OdeSpatJson', {
            method: 'POST',
            cache: 'no-cache',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(odeSpat)
        });
    }

    async function sendProcessedSpatAsync(processedSpat) {
        const key = {
            rsuId: processedSpat.originIp,
            intersectionId: processedSpat.intersectionId
        };
        if (RECORD_SCRIPT) {
            script.push(scriptUtil.buildScriptFromProcessedSpat(processedSpat, key));
        }
        await fetch('/kafka/topic.ProcessedSpat', {
            method: 'POST',
            cache: 'no-cache',
            headers: {
                'Content-Type': 'application/json',
                'x-kafka-key': JSON.stringify(key)
            },
            body: JSON.stringify(processedSpat)
        });
    }

    function buildSpatFromTemplate(spatTemplate) {
        let spatCopy = JSON.parse(JSON.stringify(spatTemplate));
        const nowMillis = Date.now();
        const dt = new Date(nowMillis);
        const dtMillis = dt.getTime();
        const dtMinute = new Date(dt.getFullYear(), dt.getMonth(), dt.getDate(), dt.getHours(), dt.getMinutes(), 0, 0);
        const minuteMillis = dtMinute.getTime();
        const millisOfMinute = dtMillis - minuteMillis;
        spatCopy.metadata.odeReceivedAt = new Date(nowMillis).toISOString();
        const dtYear = new Date(dt.getFullYear(), 0, 1, 0, 0, 0, 0);
        const yearMillis = dtYear.getTime();
        const secondOfYear = (dtMillis - yearMillis) / 1000;
        const minuteOfYear = Math.floor(secondOfYear / 60);
        spatCopy.payload.data.timeStamp = minuteOfYear;
        for (const intersection of spatCopy.payload.data.intersectionStateList.intersectionStatelist) {
            intersection.moy = minuteOfYear;
            intersection.timeStamp = millisOfMinute;
        }
        
        return spatCopy;
    }

    function buildProcessedSpatFromTemplate(spatTemplate) {
        //console.log("buildProcessedSpatFromTemplate:");
        //console.log(spatTemplate);
        let spatCopy = JSON.parse(JSON.stringify(spatTemplate));
        const nowMillis = Date.now();
        const utcTimeStampMillis = Date.parse(spatTemplate.utcTimeStamp);
        const offsetMillis = nowMillis - utcTimeStampMillis;
        //const offsetSeconds = offsetMillis / 1000.0;
        spatCopy.odeReceivedAt = new Date(nowMillis).toISOString();
        spatCopy.utcTimeStamp = spatCopy.odeReceivedAt;
        for (const state of spatCopy.states) {
            for (const event of state.stateTimeSpeed) {
                if (event["timing"] != null && event["timing"].minEndTime != null) {
                    const minEndTimeMillis = Date.parse(event["timing"].minEndTime);
                    //console.log("minEndTimeMillis: " + minEndTimeMillis);
                    //console.log("offsetMillis: " + offsetMillis);
                    event["timing"].minEndTime = new Date(minEndTimeMillis + offsetMillis).toISOString();
                }
                if (event["timing"] != null && event["timing"].maxEndTime != null) {
                    const maxEndTimeMillis = Date.parse(event["timing"].maxEndTime);
                    console.log("maxEndTimeMillis: " + maxEndTimeMillis);
                    console.log("offsetMillis: " + offsetMillis);
                    event["timing"].maxEndTime = new Date(maxEndTimeMillis + offsetMillis).toISOString();
                }
            }
        }

        //console.log(spatCopy);
        return spatCopy;
    }



    // --------------------- Send SPATs Real Time ------------------------------
    var RT_SPAT_SEND = false;
    function sendSpatsRealTime() {
        if (diffSpatEvents.length < 1) {
            console.warn("There aren't any spats to send");
            return;
        }
        
        // Determine checked SPAT phases
        const phases = getSelectedSpatPhases();
        console.log("Selected phases " + phases);
        if (phases.length == 0) {
            console.warn("No phases are selected");
            return;
        }

        RT_SPAT_SEND = true;
        document.getElementById('rtSpatControls').style = 'background-color:lightgreen';
        
        sendSpatPhasesRealTime(phases);

    }


    function stopSendingSpatsRealTime() {
        RT_SPAT_SEND = false;
        document.getElementById('rtSpatControls').style = '';
    }

    function sendSpatPhasesRealTime(phases) {
        let phaseIdx = 0;
        let phase = phases[phaseIdx];
        console.log("Send spat phase " + phase);
        let event = diffSpatEvents[phase];
        let spats = event.spats;

        let nextTime = 0;
        let idx = 0;
        console.log("Sending SPAT in " + nextTime + " ms");
        setTimeout(function sendSpatTimed() {
            if (!RT_SPAT_SEND) return;

            let dtCurrent;
            if (useProcessedSpats) {
                const processedSpat = buildProcessedSpatFromTemplate(spats[idx].json);
                dtCurrent = spats[idx].odeReceivedAt;
                sendProcessedSpatAsync(processedSpat);
            } else {
                const spat = buildSpatFromTemplate(spats[idx].json);
                dtCurrent = spats[idx].odeReceivedAt;
                sendSpatAsync(spat).then(successCallback, failureCallback);
            }

            if (idx < spats.length - 1) {
                ++idx;
                //const nextSpat = spats[idx].json;
                const dtNext = spats[idx].odeReceivedAt;
                nextTime = dtNext - dtCurrent;           
                console.log("Sending SPAT in " + nextTime + " ms");
                setTimeout(sendSpatTimed, nextTime);
            } else if (phaseIdx < phases.length - 1) {
                // Start the next phase
                ++phaseIdx;
                phase = phases[phaseIdx];
                event = diffSpatEvents[phase];
                spats = event.spats;
                nextTime = 100; // Default time until next phase
                idx = 0;
                console.log("Send spat phase " + phase);
                console.log("Sending SPAT in " + nextTime + " ms");
                setTimeout(sendSpatTimed, nextTime);
            } else {
                console.log("Completed sending SPATs");
                const spatLoop = document.getElementById('spatLoop').checked;
                if (spatLoop) {
                    console.log("Sending SPATs again");
                    phaseIdx = 0;
                    idx = 0;
                    phase = phases[phaseIdx];
                    event = diffSpatEvents[phase];
                    spats = event.spats;
                    nextTime = 100;
                    setTimeout(sendSpatTimed, nextTime);
                } else {
                    stopSendingSpatsRealTime();
                }
            }
        }, nextTime);
        

    }


    // Return a list of indices of checked spat phases
    function getSelectedSpatPhases() {
        const tbl = document.getElementById("spatTable");
        const tBody = tbl.getElementsByTagName("tbody")?.[0];
        if (!tBody) {
            log.warn("Table has no body");
            return [];
        }
        const rows = tBody?.getElementsByTagName("tr");

        console.info("Table rows " + rows.length);
        
        const phases = [];
        // Ignore header row
        for (let idx = 1; idx < rows.length; idx++) {
            const row = rows[idx];
            const cell = row.getElementsByTagName("td")[0];
            const checkbox = cell.childNodes[0];
            if (checkbox.checked) {
                phases.push(idx - 1);
            }
        }
        return phases;
    }


    // ------------------------------------ Script ------------------------------
    let RECORD_SCRIPT = false;
    //var RECORD_START_TIME = 0;
    let scriptUtil = new ScriptUtilities(Date.now(), false);

    function clearScript() {
        script.length = 0;
    }

    function startRecording() {
        RECORD_SCRIPT = true;
        scriptControls = document.getElementById('scriptControls').style = 'background-color:lightgreen';
        scriptUtil = new ScriptUtilities(Date.now(), false);
    }

    function stopRecording() {
        RECORD_SCRIPT = false;
        scriptControls = document.getElementById('scriptControls').style = '';
    }

    function downloadScript() {
        let lines = scriptUtil.buildScriptFromLines(script);
        downloadText('script.csv', lines);
    }






</script>

</html>